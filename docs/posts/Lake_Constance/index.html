<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Sina Schlegel">
<meta name="dcterms.date" content="2025-02-25">

<title>Water Level Forecast of Lake Constance – Sina Schlegel</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-8ea72dc5fed832574809a9c94082fbbb.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-ddd961a2510921635943dfbbd19534c4.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-8aa8884591a9136173b71f6048871fae.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Sina Schlegel</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/sina-schlegel-1a93a3295/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/Sinus4096"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Water Level Forecast of Lake Constance</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Time Series Analysis</div>
                <div class="quarto-category">Machine Learning</div>
                <div class="quarto-category">Python</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Sina Schlegel </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 25, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#sec-introduction" id="toc-sec-introduction" class="nav-link active" data-scroll-target="#sec-introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#sec-methodology" id="toc-sec-methodology" class="nav-link" data-scroll-target="#sec-methodology"><span class="header-section-number">2</span> Methodology</a>
  <ul>
  <li><a href="#sec-setup" id="toc-sec-setup" class="nav-link" data-scroll-target="#sec-setup"><span class="header-section-number">2.1</span> Problem Setup</a></li>
  <li><a href="#sec-data" id="toc-sec-data" class="nav-link" data-scroll-target="#sec-data"><span class="header-section-number">2.2</span> Data</a></li>
  <li><a href="#sec-preprocessing" id="toc-sec-preprocessing" class="nav-link" data-scroll-target="#sec-preprocessing"><span class="header-section-number">2.3</span> Preprocessing</a>
  <ul class="collapse">
  <li><a href="#temporal-alignment-and-target-shift" id="toc-temporal-alignment-and-target-shift" class="nav-link" data-scroll-target="#temporal-alignment-and-target-shift"><span class="header-section-number">2.3.1</span> Temporal alignment and target shift</a></li>
  <li><a href="#handling-missing-values-and-outliers" id="toc-handling-missing-values-and-outliers" class="nav-link" data-scroll-target="#handling-missing-values-and-outliers"><span class="header-section-number">2.3.2</span> Handling missing values and outliers</a></li>
  <li><a href="#traintest-split" id="toc-traintest-split" class="nav-link" data-scroll-target="#traintest-split"><span class="header-section-number">2.3.3</span> Train–test split</a></li>
  <li><a href="#log-transformation-and-feature-engineering" id="toc-log-transformation-and-feature-engineering" class="nav-link" data-scroll-target="#log-transformation-and-feature-engineering"><span class="header-section-number">2.3.4</span> Log transformation and feature engineering</a></li>
  </ul></li>
  <li><a href="#sec-decomposition" id="toc-sec-decomposition" class="nav-link" data-scroll-target="#sec-decomposition"><span class="header-section-number">2.4</span> Time-Series Decomposition</a></li>
  </ul></li>
  <li><a href="#sec-models" id="toc-sec-models" class="nav-link" data-scroll-target="#sec-models"><span class="header-section-number">3</span> Models</a>
  <ul>
  <li><a href="#sec-arma" id="toc-sec-arma" class="nav-link" data-scroll-target="#sec-arma"><span class="header-section-number">3.1</span> ARMA</a></li>
  <li><a href="#sec-linear" id="toc-sec-linear" class="nav-link" data-scroll-target="#sec-linear"><span class="header-section-number">3.2</span> Regularized Linear Regression (Ridge and Lasso)</a></li>
  <li><a href="#sec-rf" id="toc-sec-rf" class="nav-link" data-scroll-target="#sec-rf"><span class="header-section-number">3.3</span> Random Forest</a></li>
  <li><a href="#sec-nn" id="toc-sec-nn" class="nav-link" data-scroll-target="#sec-nn"><span class="header-section-number">3.4</span> Neural Network</a></li>
  </ul></li>
  <li><a href="#sec-results" id="toc-sec-results" class="nav-link" data-scroll-target="#sec-results"><span class="header-section-number">4</span> Results</a>
  <ul>
  <li><a href="#sec-accuracy" id="toc-sec-accuracy" class="nav-link" data-scroll-target="#sec-accuracy"><span class="header-section-number">4.1</span> Forecast Accuracy</a></li>
  <li><a href="#sec-interpretation" id="toc-sec-interpretation" class="nav-link" data-scroll-target="#sec-interpretation"><span class="header-section-number">4.2</span> Interpretation of Drivers</a></li>
  <li><a href="#sec-baseline" id="toc-sec-baseline" class="nav-link" data-scroll-target="#sec-baseline"><span class="header-section-number">4.3</span> Comparison to Baseline</a></li>
  </ul></li>
  <li><a href="#sec-conclusion" id="toc-sec-conclusion" class="nav-link" data-scroll-target="#sec-conclusion"><span class="header-section-number">5</span> Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="sec-introduction" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="sec-introduction"><span class="header-section-number">1</span> Introduction</h2>
<p>Water levels in large lakes are subject to complex dynamics driven by meteorological conditions, hydrology, and long-term climate trends. For Lake Constance, these fluctuations have direct operational consequences. During periods of high water levels, steeper entry and exit angles at ferry ramps complicate boarding and disembarking, particularly for low-profile vehicles that may even be restricted to avoid damage. Conversely, low water levels can reduce cargo capacity, require stricter loading rules, and increase delays and fuel consumption due to suboptimal routing and load distribution.</p>
<p>These operational frictions lead to customer dissatisfaction, lost revenue, and higher overall costs for ferry companies operating on Lake Constance. Reliable short-term water level forecasts are therefore highly valuable, as they enable better planning of schedules, loading strategies, and potential service suspensions.</p>
<p>In this project, we develop models to predict next-day water levels at Lake Constance using a comprehensive set of meteorological, hydrological, and climate-related features. Formally, let</p>
<ul>
<li><span class="math inline">\(y_t\)</span> denote the observed lake level on day <span class="math inline">\(t\)</span>, and<br>
</li>
<li><span class="math inline">\({x}_t\)</span> the feature vector observed on day <span class="math inline">\(t\)</span>.</li>
</ul>
<p>The one-step-ahead forecasting problem is to construct a model <span class="math inline">\(f(\cdot)\)</span> such that</p>
<p><span class="math display">\[
\hat{y}_{t+1} = f(x_t), \qquad t = 1,\dots,T-1,
\]</span></p>
<p>and to evaluate its out-of-sample performance on a hold-out period.</p>
<p>We compare several classes of models:</p>
<ul>
<li>a classical ARMA time-series model,<br>
</li>
<li>regularized linear regression (Ridge and Lasso),<br>
</li>
<li>a non-linear Random Forest, and<br>
</li>
<li>a feed-forward Neural Network.</li>
</ul>
<p>Performance is assessed via the root mean squared error (RMSE),</p>
<p><span class="math display">\[
\text{RMSE} =
\sqrt{\frac{1}{N}\sum_{t=1}^{N}(y_t - \hat{y}_t)^2},
\]</span></p>
<p>and benchmarked against a naive persistence model (_{t+1}^{} = y_t). We find that modern machine learning methods and regularized linear models substantially improve upon the naive baseline, with Ridge regression achieving the lowest RMSE in our experiments.</p>
<hr>
</section>
<section id="sec-methodology" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="sec-methodology"><span class="header-section-number">2</span> Methodology</h2>
<section id="sec-setup" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="sec-setup"><span class="header-section-number">2.1</span> Problem Setup</h3>
<p>We focus on daily water levels measured in Constance, one of the standard gauging stations at Lake Constance. Let <span class="math inline">\(\{y_t\}_{t=1}^T\)</span> denote the water level time series (in cm). The goal is to forecast <span class="math inline">\(y_{t+1}\)</span> using information available up to day <span class="math inline">\(t\)</span>.</p>
<p>The general prediction framework can be written as</p>
<p><span class="math display">\[
y_{t+1} = f(x_t) + \varepsilon_{t+1},
\]</span></p>
<p>where <span class="math inline">\(x_t\)</span> contains contemporaneous and lagged features and <span class="math inline">\(\varepsilon_{t+1}\)</span> is an error term with mean zero.</p>
</section>
<section id="sec-data" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="sec-data"><span class="header-section-number">2.2</span> Data</h3>
<p>We combine several datasets to construct <span class="math inline">\({x}_t\)</span>:</p>
<ol type="1">
<li><p><strong>Hydrological data</strong></p>
<ul>
<li>Daily water levels of Lake Constance (station Constance) from 1924 to 2023.<br>
</li>
<li>Weekly groundwater levels from a nearby station.</li>
</ul></li>
<li><p><strong>Meteorological data</strong> (daily)</p>
<ul>
<li>humidity, mean temperature, precipitation,<br>
</li>
<li>snow depth, sea-level pressure,<br>
</li>
<li>sunshine duration, global radiation, wind speed.</li>
</ul></li>
<li><p><strong>Lunar data</strong></p>
<ul>
<li>Daily moon illumination from NASA’s Horizons system, representing the fraction of the moon’s disk that is illuminated.</li>
</ul></li>
<li><p><strong>Climate change data</strong></p>
<ul>
<li>Annual mean surface temperature change for Switzerland, used as a proxy for long-term climate trends.</li>
</ul></li>
</ol>
<p>All datasets are converted to CSV format, cleaned, and merged by date to form a single panel. The final modeling period spans 1973–2023, providing a long history with clear seasonal and interannual patterns.</p>
</section>
<section id="sec-preprocessing" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="sec-preprocessing"><span class="header-section-number">2.3</span> Preprocessing</h3>
<p>Several preprocessing steps are required before modeling:</p>
<section id="temporal-alignment-and-target-shift" class="level4" data-number="2.3.1">
<h4 data-number="2.3.1" class="anchored" data-anchor-id="temporal-alignment-and-target-shift"><span class="header-section-number">2.3.1</span> Temporal alignment and target shift</h4>
<p>Because we want to predict tomorrow’s water level using today’s information, the target series is shifted:</p>
<p><span class="math display">\[
\tilde{y}_t = y_{t+1}, \qquad t = 1,\dots,T-1,
\]</span></p>
<p>so that each row <span class="math inline">\((x_t, \tilde{y}_t)\)</span> encodes features at day <span class="math inline">\(t\)</span> and the corresponding water level on day (t+1).</p>
</section>
<section id="handling-missing-values-and-outliers" class="level4" data-number="2.3.2">
<h4 data-number="2.3.2" class="anchored" data-anchor-id="handling-missing-values-and-outliers"><span class="header-section-number">2.3.2</span> Handling missing values and outliers</h4>
<ul>
<li>Groundwater (weekly) and climate change (annual) data are forward-filled to match the daily resolution.<br>
</li>
<li>Missing values in weather variables (e.g., snow depth, sunshine, wind speed, radiation) are imputed using **seasonal monthly means, preserving seasonal patterns.<br>
</li>
<li>Outliers are identified via time-series plots and corrected using a 30-day rolling mean where appropriate, relying only on historical/current information to avoid data leakage.</li>
</ul>
</section>
<section id="traintest-split" class="level4" data-number="2.3.3">
<h4 data-number="2.3.3" class="anchored" data-anchor-id="traintest-split"><span class="header-section-number">2.3.3</span> Train–test split</h4>
<p>To ensure a realistic evaluation, we use a temporal split:</p>
<ul>
<li>Training set: data up to 2017 (inclusive).<br>
</li>
<li>Test set: 2018–2023.</li>
</ul>
<p>This respects the time order and avoids training on future information.</p>
</section>
<section id="log-transformation-and-feature-engineering" class="level4" data-number="2.3.4">
<h4 data-number="2.3.4" class="anchored" data-anchor-id="log-transformation-and-feature-engineering"><span class="header-section-number">2.3.4</span> Log transformation and feature engineering</h4>
<p><img src="Images/Density_plot.png" style="float: right; width: 30%; margin-left: 15px;"></p>
<p>Exploratory analysis shows that water levels are right-skewed and approximately log-normally distributed. A log transformation stabilizes variance:</p>
<p><span class="math display">\[
z_t = \log(y_t).
\]</span></p>
<p>To capture temporal dependence, we add lagged levels as features:</p>
<p><span class="math display">\[
z_{t-1}, z_{t-2}, \dots, z_{t-7},
\]</span></p>
<p>representing the last seven days of water levels. Because these lags would be known at prediction time, they do not introduce look-ahead bias.</p>
<p>For models that can exploit seasonality directly (Random Forest, Neural Network), we additionally encode calendar effects via cyclical features, e.g.</p>
<p><span class="math display">\[
\begin{aligned}
\text{month\_sin}_t &amp;= \sin\left( 2\pi \cdot \frac{\text{month}(t)}{12} \right), \\
\text{month\_cos}_t &amp;= \cos\left( 2\pi \cdot \frac{\text{month}(t)}{12} \right),
\end{aligned}
\]</span></p>
<p>and analogous terms for week-of-year, half-year, etc.</p>
<p>For linear models and ARMA, we work on deseasonalized versions of the series to meet stationarity and linearity assumptions (see below).</p>
</section>
</section>
<section id="sec-decomposition" class="level3" data-number="2.4">
<h3 data-number="2.4" class="anchored" data-anchor-id="sec-decomposition"><span class="header-section-number">2.4</span> Time-Series Decomposition</h3>
<p>Fourier analysis and seasonal plots reveal strong annual and semi-annual components in the water level series, but no pronounced long-term trend. For models that require approximate stationarity (ARMA) or that may be dominated by spurious seasonal correlations (linear regression), we:</p>
<ol type="1">
<li>Remove seasonal components from the target and from features that share similar seasonality.<br>
</li>
<li>Detrend only those features exhibiting strong trends unrelated to the target (notably the climate change indicator).</li>
</ol>
<p>Stationarity is confirmed using Augmented Dickey–Fuller (ADF) and KPSS tests on the deseasonalized target.</p>
<hr>
</section>
</section>
<section id="sec-models" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="sec-models"><span class="header-section-number">3</span> Models</h2>
<p>We compare four main model classes.</p>
<section id="sec-arma" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="sec-arma"><span class="header-section-number">3.1</span> ARMA</h3>
<p>The ARMA model treats deseasonalized log water levels as a univariate time series <span class="math inline">\(\tilde{z}_t\)</span> and assumes</p>
<p><span class="math display">\[
\tilde{z}_t = \mu + \sum_{i=1}^{p} \phi_i \tilde{z}_{t-i}
+ \sum_{j=1}^{q} \theta_j \varepsilon_{t-j}
+ \varepsilon_t,
\qquad \varepsilon_t \sim \mathcal{N}(0,\sigma^2).
\]</span></p>
<p>We perform a grid search over orders <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> on the training set using time-series cross-validation, selecting the combination that minimizes RMSE. The optimal configuration is ARMA(4,3). Forecasts are generated in a rolling fashion, always using the most recent observed (or previously predicted) values.</p>
</section>
<section id="sec-linear" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="sec-linear"><span class="header-section-number">3.2</span> Regularized Linear Regression (Ridge and Lasso)</h3>
<p>After deseasonalization and standardization, we model the relationship between features (_t) and target <span class="math inline">\(\tilde{z}_t\)</span> via</p>
<p><span class="math display">\[
\tilde{z}_t = \beta_0 + x_t^\top \boldsymbol{\beta} + \varepsilon_t,
\]</span></p>
<p>with two different regularization schemes:</p>
<ul>
<li><strong>Ridge regression</strong> solves<br>
<span class="math display">\[
\min_{\beta_0,\boldsymbol{\beta}}
\sum_{t} (\tilde{z}_t - \beta_0 - \mathbf{x}_t^\top \boldsymbol{\beta})^2
+ \lambda \lVert \boldsymbol{\beta} \rVert_2^2,
\]</span></li>
<li><strong>Lasso regression</strong> solves<br>
<span class="math display">\[
\min_{\beta_0,\boldsymbol{\beta}}
\sum_{t} (\tilde{z}_t - \beta_0 - \mathbf{x}_t^\top \boldsymbol{\beta})^2
+ \lambda \lVert \boldsymbol{\beta} \rVert_1.
\]</span></li>
</ul>
<p>The regularization parameter <span class="math inline">\(\lambda\)</span> is selected via grid search with TimeSeriesSplit cross-validation. Ridge primarily shrinks coefficients, while Lasso additionally performs variable selection by driving some coefficients to zero.</p>
</section>
<section id="sec-rf" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="sec-rf"><span class="header-section-number">3.3</span> Random Forest</h3>
<p>Random Forest is an ensemble of decision trees. Each tree (f^{(b)}) is fitted on a bootstrap sample of the training data, considering a random subset of features at each split. The final prediction is the average</p>
<p><span class="math display">\[
\hat{z}_{t+1}^{\text{RF}} = \frac{1}{B} \sum_{b=1}^{B} f^{(b)}({x}_t).
\]</span></p>
<p>Hyperparameters such as the number of trees, maximum depth, and minimum samples per split are tuned via RandomizedSearchCV with time-series splits. After tuning, we train a larger forest (e.g.&nbsp;(B = 500) trees) using the best configuration. Random Forest additionally provides feature importance scores, which we exploit to interpret the drivers of predictability.</p>
</section>
<section id="sec-nn" class="level3" data-number="3.4">
<h3 data-number="3.4" class="anchored" data-anchor-id="sec-nn"><span class="header-section-number">3.4</span> Neural Network</h3>
<p>For the neural network, we use a multi-layer perceptron (MLP) implemented via scikit-learn’s <code>MLPRegressor</code>. The MLP models a non-linear mapping</p>
<p><span class="math display">\[
\hat{z}_{t+1}^{\text{NN}} = f_{\text{NN}}(\mathbf{x}_t; \Theta),
\]</span></p>
<p>where <span class="math inline">\(\Theta\)</span> denotes all weights and biases. The chosen architecture has three hidden layers with 32, 64, and 32 neurons, respectively, ReLU activations, and the Adam optimizer with learning rate <span class="math inline">\(10^{-4}\)</span>. An <span class="math inline">\(L_2\)</span> penalty with <span class="math inline">\(\alpha = 0.01\)</span> controls overfitting.</p>
<p>Hyperparameters (layer sizes, batch size, learning rate, regularization) are tuned via <code>RandomizedSearchCV</code>. We assess feature importance using permutation importance, which measures the increase in prediction error when a feature is randomly shuffled.</p>
<hr>
</section>
</section>
<section id="sec-results" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="sec-results"><span class="header-section-number">4</span> Results</h2>
<section id="sec-accuracy" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="sec-accuracy"><span class="header-section-number">4.1</span> Forecast Accuracy</h3>
<p>Table 1 reports RMSE values for all models on the test set (2018–2023), along with the naive “yesterday = today” benchmark.</p>
<p><strong>Table 1: Out-of-sample RMSE for next-day water level forecasts (cm).</strong></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Model</th>
<th>RMSE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Naive (<span class="math inline">\(y_t\)</span>)</td>
<td>2.85</td>
</tr>
<tr class="even">
<td>ARMA(4,3)</td>
<td>2.12</td>
</tr>
<tr class="odd">
<td>Ridge Regression</td>
<td>1.40</td>
</tr>
<tr class="even">
<td>Lasso Regression</td>
<td>1.43</td>
</tr>
<tr class="odd">
<td>Random Forest</td>
<td>2.04</td>
</tr>
<tr class="even">
<td>Neural Network</td>
<td>1.96</td>
</tr>
</tbody>
</table>
<p>Ridge regression achieves the lowest RMSE (1.40 cm), followed closely by Lasso and the neural network. Both Random Forest and ARMA substantially improve over the naive baseline, but remain less accurate than the best linear and neural models.</p>
</section>
<section id="sec-interpretation" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="sec-interpretation"><span class="header-section-number">4.2</span> Interpretation of Drivers</h3>
<p>Across Random Forest and Neural Network models, lagged water levels, in particular the first lag (z_{t-1}), dominate feature importance. In the Random Forest, lag 1 alone accounts for more than 99% of the total importance, confirming that water levels are highly persistent. When lag 1 is excluded to inspect secondary drivers, precipitation and additional lagged levels emerge as the most influential features, while snow depth contributes little additional information.</p>
<p>Permutation importance for the neural network confirms the same pattern:</p>
<ul>
<li>lagged levels are crucial,<br>
</li>
<li>precipitation plays a supporting role,<br>
</li>
<li>other weather variables, lunar features, and long-term climate indicators appear less relevant for one-day-ahead forecasts.</li>
</ul>
</section>
<section id="sec-baseline" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="sec-baseline"><span class="header-section-number">4.3</span> Comparison to Baseline</h3>
<p>Relative to the naive model (RMSE 2.85 cm), the best model (Ridge, 1.40 cm) reduces the typical forecast error by roughly 50%. Even the ARMA model improves RMSE by about 25%. In operational terms, this tighter error band enables ferry operators to:</p>
<ul>
<li>better anticipate when ramps may become too steep or too shallow,<br>
</li>
<li>adjust loading strategies in advance, and<br>
</li>
<li>communicate potential disruptions earlier to customers.</li>
</ul>
<hr>
</section>
</section>
<section id="sec-conclusion" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="sec-conclusion"><span class="header-section-number">5</span> Conclusion</h2>
<p>This study investigates next-day water level forecasts for Lake Constance using a rich feature set combining hydrological, meteorological, lunar, and climate change data. After careful preprocessing, feature engineering, and model tuning, we compare ARMA, regularized linear regressions, Random Forests, and a neural network.</p>
<p>Our main findings are:</p>
<ol type="1">
<li>Lagged water levels are by far the most important predictors of tomorrow’s level; one-day persistence dominates the dynamics.<br>
</li>
<li>Precipitation and additional lags provide useful supplementary information, while other variables play a comparatively minor role for one-day-ahead predictions.<br>
</li>
<li>Ridge regression achieves the best overall performance, slightly outperforming Lasso and the neural network, and clearly improving upon ARMA and Random Forest.<br>
</li>
<li>All advanced models significantly outperform a naive persistence benchmark, reducing RMSE by up to 50%.</li>
</ol>
<p>From a practical perspective, these results demonstrate that relatively simple, interpretable models such as Ridge regression can already deliver highly accurate forecasts that are suitable for operational decision-making. Future work could extend the horizon to multi-day forecasts, incorporate probabilistic prediction intervals, or explore spatially distributed models that jointly consider multiple gauging stations around Lake Constance.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = true;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>